(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Rolly = factory());
}(this, (function () { 'use strict';

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	function E () {
	  // Keep this empty so it's easier to inherit from
	  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
	}

	E.prototype = {
	  on: function (name, callback, ctx) {
	    var e = this.e || (this.e = {});

	    (e[name] || (e[name] = [])).push({
	      fn: callback,
	      ctx: ctx
	    });

	    return this;
	  },

	  once: function (name, callback, ctx) {
	    var self = this;
	    function listener () {
	      self.off(name, listener);
	      callback.apply(ctx, arguments);
	    }
	    listener._ = callback;
	    return this.on(name, listener, ctx);
	  },

	  emit: function (name) {
	    var data = [].slice.call(arguments, 1);
	    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
	    var i = 0;
	    var len = evtArr.length;

	    for (i; i < len; i++) {
	      evtArr[i].fn.apply(evtArr[i].ctx, data);
	    }

	    return this;
	  },

	  off: function (name, callback) {
	    var e = this.e || (this.e = {});
	    var evts = e[name];
	    var liveEvents = [];

	    if (evts && callback) {
	      for (var i = 0, len = evts.length; i < len; i++) {
	        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
	          liveEvents.push(evts[i]);
	      }
	    }

	    // Remove event from queue to prevent memory leak
	    // Suggested by https://github.com/lazd
	    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

	    (liveEvents.length)
	      ? e[name] = liveEvents
	      : delete e[name];

	    return this;
	  }
	};

	var tinyEmitter = E;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var lethargy = createCommonjsModule(function (module, exports) {
	// Generated by CoffeeScript 1.9.2
	(function() {
	  var root;

	  root = 'object' !== "undefined" && exports !== null ? exports : this;

	  root.Lethargy = (function() {
	    function Lethargy(stability, sensitivity, tolerance, delay) {
	      this.stability = stability != null ? Math.abs(stability) : 8;
	      this.sensitivity = sensitivity != null ? 1 + Math.abs(sensitivity) : 100;
	      this.tolerance = tolerance != null ? 1 + Math.abs(tolerance) : 1.1;
	      this.delay = delay != null ? delay : 150;
	      this.lastUpDeltas = (function() {
	        var i, ref, results;
	        results = [];
	        for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
	          results.push(null);
	        }
	        return results;
	      }).call(this);
	      this.lastDownDeltas = (function() {
	        var i, ref, results;
	        results = [];
	        for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
	          results.push(null);
	        }
	        return results;
	      }).call(this);
	      this.deltasTimestamp = (function() {
	        var i, ref, results;
	        results = [];
	        for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
	          results.push(null);
	        }
	        return results;
	      }).call(this);
	    }

	    Lethargy.prototype.check = function(e) {
	      var lastDelta;
	      e = e.originalEvent || e;
	      if (e.wheelDelta != null) {
	        lastDelta = e.wheelDelta;
	      } else if (e.deltaY != null) {
	        lastDelta = e.deltaY * -40;
	      } else if ((e.detail != null) || e.detail === 0) {
	        lastDelta = e.detail * -40;
	      }
	      this.deltasTimestamp.push(Date.now());
	      this.deltasTimestamp.shift();
	      if (lastDelta > 0) {
	        this.lastUpDeltas.push(lastDelta);
	        this.lastUpDeltas.shift();
	        return this.isInertia(1);
	      } else {
	        this.lastDownDeltas.push(lastDelta);
	        this.lastDownDeltas.shift();
	        return this.isInertia(-1);
	      }
	      return false;
	    };

	    Lethargy.prototype.isInertia = function(direction) {
	      var lastDeltas, lastDeltasNew, lastDeltasOld, newAverage, newSum, oldAverage, oldSum;
	      lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;
	      if (lastDeltas[0] === null) {
	        return direction;
	      }
	      if (this.deltasTimestamp[(this.stability * 2) - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[(this.stability * 2) - 1]) {
	        return false;
	      }
	      lastDeltasOld = lastDeltas.slice(0, this.stability);
	      lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);
	      oldSum = lastDeltasOld.reduce(function(t, s) {
	        return t + s;
	      });
	      newSum = lastDeltasNew.reduce(function(t, s) {
	        return t + s;
	      });
	      oldAverage = oldSum / lastDeltasOld.length;
	      newAverage = newSum / lastDeltasNew.length;
	      if (Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && (this.sensitivity < Math.abs(newAverage))) {
	        return direction;
	      } else {
	        return false;
	      }
	    };

	    Lethargy.prototype.showLastUpDeltas = function() {
	      return this.lastUpDeltas;
	    };

	    Lethargy.prototype.showLastDownDeltas = function() {
	      return this.lastDownDeltas;
	    };

	    return Lethargy;

	  })();

	}).call(commonjsGlobal);
	});

	var support = (function getSupport() {
	    return {
	        hasWheelEvent: 'onwheel' in document,
	        hasMouseWheelEvent: 'onmousewheel' in document,
	        hasTouch: 'ontouchstart' in document,
	        hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
	        hasPointer: !!window.navigator.msPointerEnabled,
	        hasKeyDown: 'onkeydown' in document,
	        isFirefox: navigator.userAgent.indexOf('Firefox') > -1
	    };
	})();

	var toString = Object.prototype.toString,
	    hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var bindallStandalone = function(object) {
	    if(!object) return console.warn('bindAll requires at least one argument.');

	    var functions = Array.prototype.slice.call(arguments, 1);

	    if (functions.length === 0) {

	        for (var method in object) {
	            if(hasOwnProperty$1.call(object, method)) {
	                if(typeof object[method] == 'function' && toString.call(object[method]) == "[object Function]") {
	                    functions.push(method);
	                }
	            }
	        }
	    }

	    for(var i = 0; i < functions.length; i++) {
	        var f = functions[i];
	        object[f] = bind(object[f], object);
	    }
	};

	/*
	    Faster bind without specific-case checking. (see https://coderwall.com/p/oi3j3w).
	    bindAll is only needed for events binding so no need to make slow fixes for constructor
	    or partial application.
	*/
	function bind(func, context) {
	  return function() {
	    return func.apply(context, arguments);
	  };
	}

	var Lethargy = lethargy.Lethargy;



	var EVT_ID = 'virtualscroll';

	var src = VirtualScroll;

	var keyCodes = {
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    DOWN: 40,
	    SPACE: 32
	};

	function VirtualScroll(options) {
	    bindallStandalone(this, '_onWheel', '_onMouseWheel', '_onTouchStart', '_onTouchMove', '_onKeyDown');

	    this.el = window;
	    if (options && options.el) {
	        this.el = options.el;
	        delete options.el;
	    }
	    this.options = objectAssign({
	        mouseMultiplier: 1,
	        touchMultiplier: 2,
	        firefoxMultiplier: 15,
	        keyStep: 120,
	        preventTouch: false,
	        unpreventTouchClass: 'vs-touchmove-allowed',
	        limitInertia: false
	    }, options);

	    if (this.options.limitInertia) this._lethargy = new Lethargy();

	    this._emitter = new tinyEmitter();
	    this._event = {
	        y: 0,
	        x: 0,
	        deltaX: 0,
	        deltaY: 0
	    };
	    this.touchStartX = null;
	    this.touchStartY = null;
	    this.bodyTouchAction = null;

	    if (this.options.passive !== undefined) {
	        this.listenerOptions = {passive: this.options.passive};
	    }
	}

	VirtualScroll.prototype._notify = function(e) {
	    var evt = this._event;
	    evt.x += evt.deltaX;
	    evt.y += evt.deltaY;

	   this._emitter.emit(EVT_ID, {
	        x: evt.x,
	        y: evt.y,
	        deltaX: evt.deltaX,
	        deltaY: evt.deltaY,
	        originalEvent: e
	   });
	};

	VirtualScroll.prototype._onWheel = function(e) {
	    var options = this.options;
	    if (this._lethargy && this._lethargy.check(e) === false) return;
	    var evt = this._event;

	    // In Chrome and in Firefox (at least the new one)
	    evt.deltaX = e.wheelDeltaX || e.deltaX * -1;
	    evt.deltaY = e.wheelDeltaY || e.deltaY * -1;

	    // for our purpose deltamode = 1 means user is on a wheel mouse, not touch pad
	    // real meaning: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent#Delta_modes
	    if(support.isFirefox && e.deltaMode == 1) {
	        evt.deltaX *= options.firefoxMultiplier;
	        evt.deltaY *= options.firefoxMultiplier;
	    }

	    evt.deltaX *= options.mouseMultiplier;
	    evt.deltaY *= options.mouseMultiplier;

	    this._notify(e);
	};

	VirtualScroll.prototype._onMouseWheel = function(e) {
	    if (this.options.limitInertia && this._lethargy.check(e) === false) return;

	    var evt = this._event;

	    // In Safari, IE and in Chrome if 'wheel' isn't defined
	    evt.deltaX = (e.wheelDeltaX) ? e.wheelDeltaX : 0;
	    evt.deltaY = (e.wheelDeltaY) ? e.wheelDeltaY : e.wheelDelta;

	    this._notify(e);
	};

	VirtualScroll.prototype._onTouchStart = function(e) {
	    var t = (e.targetTouches) ? e.targetTouches[0] : e;
	    this.touchStartX = t.pageX;
	    this.touchStartY = t.pageY;
	};

	VirtualScroll.prototype._onTouchMove = function(e) {
	    var options = this.options;
	    if(options.preventTouch
	        && !e.target.classList.contains(options.unpreventTouchClass)) {
	        e.preventDefault();
	    }

	    var evt = this._event;

	    var t = (e.targetTouches) ? e.targetTouches[0] : e;

	    evt.deltaX = (t.pageX - this.touchStartX) * options.touchMultiplier;
	    evt.deltaY = (t.pageY - this.touchStartY) * options.touchMultiplier;

	    this.touchStartX = t.pageX;
	    this.touchStartY = t.pageY;

	    this._notify(e);
	};

	VirtualScroll.prototype._onKeyDown = function(e) {
	    var evt = this._event;
	    evt.deltaX = evt.deltaY = 0;
	    var windowHeight = window.innerHeight - 40;

	    switch(e.keyCode) {
	        case keyCodes.LEFT:
	        case keyCodes.UP:
	            evt.deltaY = this.options.keyStep;
	            break;

	        case keyCodes.RIGHT:
	        case keyCodes.DOWN:
	            evt.deltaY = - this.options.keyStep;
	            break;
	        case keyCodes.SPACE && e.shiftKey:
	            evt.deltaY = windowHeight;
	            break;
	        case keyCodes.SPACE:
	            evt.deltaY = - windowHeight;
	            break;
	        default:
	            return;
	    }

	    this._notify(e);
	};

	VirtualScroll.prototype._bind = function() {
	    if(support.hasWheelEvent) this.el.addEventListener('wheel', this._onWheel, this.listenerOptions);
	    if(support.hasMouseWheelEvent) this.el.addEventListener('mousewheel', this._onMouseWheel, this.listenerOptions);

	    if(support.hasTouch) {
	        this.el.addEventListener('touchstart', this._onTouchStart, this.listenerOptions);
	        this.el.addEventListener('touchmove', this._onTouchMove, this.listenerOptions);
	    }

	    if(support.hasPointer && support.hasTouchWin) {
	        this.bodyTouchAction = document.body.style.msTouchAction;
	        document.body.style.msTouchAction = 'none';
	        this.el.addEventListener('MSPointerDown', this._onTouchStart, true);
	        this.el.addEventListener('MSPointerMove', this._onTouchMove, true);
	    }

	    if(support.hasKeyDown) document.addEventListener('keydown', this._onKeyDown);
	};

	VirtualScroll.prototype._unbind = function() {
	    if(support.hasWheelEvent) this.el.removeEventListener('wheel', this._onWheel);
	    if(support.hasMouseWheelEvent) this.el.removeEventListener('mousewheel', this._onMouseWheel);

	    if(support.hasTouch) {
	        this.el.removeEventListener('touchstart', this._onTouchStart);
	        this.el.removeEventListener('touchmove', this._onTouchMove);
	    }

	    if(support.hasPointer && support.hasTouchWin) {
	        document.body.style.msTouchAction = this.bodyTouchAction;
	        this.el.removeEventListener('MSPointerDown', this._onTouchStart, true);
	        this.el.removeEventListener('MSPointerMove', this._onTouchMove, true);
	    }

	    if(support.hasKeyDown) document.removeEventListener('keydown', this._onKeyDown);
	};

	VirtualScroll.prototype.on = function(cb, ctx) {
	  this._emitter.on(EVT_ID, cb, ctx);

	  var events = this._emitter.e;
	  if (events && events[EVT_ID] && events[EVT_ID].length === 1) this._bind();
	};

	VirtualScroll.prototype.off = function(cb, ctx) {
	  this._emitter.off(EVT_ID, cb, ctx);

	  var events = this._emitter.e;
	  if (!events[EVT_ID] || events[EVT_ID].length <= 0) this._unbind();
	};

	VirtualScroll.prototype.reset = function() {
	    var evt = this._event;
	    evt.x = 0;
	    evt.y = 0;
	};

	VirtualScroll.prototype.destroy = function() {
	    this._emitter.off();
	    this._unbind();
	};

	// check document first so it doesn't error in node.js
	var style = typeof document != 'undefined'
	  ? document.createElement('p').style
	  : {};

	var prefixes = ['O', 'ms', 'Moz', 'Webkit'];
	var upper = /([A-Z])/g;
	var memo = {};

	/**
	 * prefix `key`
	 *
	 *   prefix('transform') // => WebkitTransform
	 *
	 * @param {String} key
	 * @return {String}
	 * @api public
	 */
	function prefix(key){
	  // Camel case
	  key = key.replace(/-([a-z])/g, function(_, char){
	    return char.toUpperCase()
	  });

	  // Without prefix
	  if (style[key] !== undefined) return key

	  // With prefix
	  var Key = key.charAt(0).toUpperCase() + key.slice(1);
	  var i = prefixes.length;
	  while (i--) {
	    var name = prefixes[i] + Key;
	    if (style[name] !== undefined) return name
	  }

	  return key
	}

	/**
	 * Memoized version of `prefix`
	 *
	 * @param {String} key
	 * @return {String}
	 * @api public
	 */
	function prefixMemozied(key){
	  return key in memo
	    ? memo[key]
	    : memo[key] = prefix(key)
	}

	/**
	 * Create a dashed prefix
	 *
	 * @param {String} key
	 * @return {String}
	 * @api public
	 */
	function prefixDashed(key){
	  key = prefix(key);
	  if (upper.test(key)) {
	    key = '-' + key.replace(upper, '-$1');
	    upper.lastIndex = 0;
	  }
	  return key.toLowerCase()
	}

	var prefix_1 = prefixMemozied;
	var dash = prefixDashed;
	prefix_1.dash = dash;

	const utils = {
	  getCSSTransform(value, direction) {
	    return direction === 'vertical'
	      ? `translate3d(0, ${value}px, 0)`
	      : `translate3d(${value}px, 0, 0)`;
	  },

	  getElements(selector, context = document) {
	    const els = context.querySelectorAll(selector);
	    return Array.prototype.slice.call(els, 0);
	  }
	};

	class Parallax {
	  constructor(context, options) {
	    this.options = options;

	    this.transformPrefix = prefix_1('transform');

	    this.state = { caching: false, cache: null };
	    this.DOM = { context };
	    this.DOM.els = utils.getElements(this.options.parallax.selector, context);
	  }

	  reload() {
	    this.DOM.els = utils.getElements(
	      this.options.parallax.selector,
	      this.DOM.context
	    );
	  }

	  run(parentState) {
	    this.DOM.els.forEach((el, index) => {
	      if (!this.state.cache || this.state.caching) return;
	      const cache = this.state.cache[index];
	      const current = parentState.current;

	      if (!cache) return;

	      // Set style for parallax element with type 'default'
	      if (cache.type === 'default') {
	        const { inView, transform } = this.calc(cache, parentState);

	        if (inView) {
	          el.style[this.transformPrefix] = utils.getCSSTransform(
	            transform,
	            this.options.direction
	          );
	        }
	      } else {
	        // Do other things for parallax element with other type
	        try {
	          const state = Object.assign({}, parentState);

	          Object.keys(parentState)
	            .filter(
	              key =>
	                ![
	                  'current',
	                  'last',
	                  'target',
	                  'width',
	                  'height',
	                  'bounding'
	                ].includes(key)
	            )
	            .forEach(key => delete state[key]);

	          this.options.parallax[cache.type].run.call(this, { cache, state });
	        } catch (error) {
	          const msg =
	            'ScrollManager.run: error occured while calling run function for parallax elements with type';
	          console.error(`${msg} '${cache.type}'`, error);
	        }
	      }
	    });
	  }

	  // Calculate usefull values
	  // transform: the transform value according to speed (data-speed) values
	  // start: distance between start of screen and start of element (top||left)
	  // end: distance between start of screen and end of element (bottom||right)
	  // inView: indicates whether the element is into view
	  calc(cache, state) {
	    const vertical = this.options.direction === 'vertical';
	    const { top, right, bottom, left, center, speed } = cache;
	    const { width, height, current } = state;

	    const transform = ((vertical ? top : left) + center - current) * speed;
	    const start = Math.round((vertical ? top : left) + transform - current);
	    const end = Math.round((vertical ? bottom : right) + transform - current);
	    const inView = end > 0 && start < (vertical ? height : width);

	    return { transform, start, end, inView };
	  }

	  cache(parentState) {
	    return new Promise((resolve, reject) => {
	      this.state.caching = true;
	      this.state.cache = [];

	      const isVertical = this.options.direction === 'vertical';
	      const scrollOffset = parentState.target;

	      this.DOM.els.forEach((el, index) => {
	        el.style.display = null;
	        const computedDisplay = window.getComputedStyle(el).display;
	        if (computedDisplay === 'none') {
	          this.state.cache.push(null);
	          return;
	        }

	        if (computedDisplay === 'inline') {
	          el.style.display = 'block';
	        }
	        el.style[this.transformPrefix] = 'none';

	        const bounding = el.getBoundingClientRect();
	        let cache = {
	          el,
	          top: isVertical ? bounding.top + scrollOffset : bounding.top,
	          left: isVertical ? bounding.left : bounding.left + scrollOffset,
	          right: isVertical ? bounding.right : bounding.right + scrollOffset,
	          center: isVertical ? bounding.height / 2 : bounding.width / 2,
	          bottom: isVertical ? bounding.bottom + scrollOffset : bounding.bottom,
	          speed: parseFloat(el.getAttribute('data-speed')) || -1,
	          type: el.getAttribute('data-parallax') || 'default'
	        };

	        // Set default style for parallax element with type 'default'
	        if (cache.type === 'default') {
	          const { transform } = this.calc(cache, parentState);
	          el.style[this.transformPrefix] = utils.getCSSTransform(
	            transform,
	            this.options.direction
	          );
	        } else {
	          // Do custom things for parallax elements with custom type
	          if (this.options.parallax[cache.type]) {
	            const getCache = this.options.parallax[cache.type].getCache;
	            if (getCache) {
	              const extend = getCache.call(this, { cache, state: parentState });
	              cache = Object.assign(cache, extend);
	            }
	          }
	        }

	        this.state.cache.push(cache);
	      });

	      this.state.caching = false;
	      resolve();
	    });
	  }
	}

	class Scenes {
	  constructor(context, options) {
	    this.options = options;

	    this.state = { caching: false, cache: null };
	    this.DOM = { context };
	    this.DOM.els = utils.getElements(this.options.scenes.selector, context);
	  }

	  reload() {
	    this.DOM.els = utils.getElements(
	      this.options.scenes.selector,
	      this.DOM.context
	    );
	  }

	  run(parentState) {
	    this.DOM.els.forEach((el, index) => {
	      if (!this.state.cache || this.state.caching) return;

	      const current = parentState.current;
	      const height = parentState.height;
	      const cache = this.state.cache[index];

	      if (!cache) return;

	      cache.progress = this.getProgress(current, height, cache);
	      const inView = this.checkInView(current, height, cache);

	      // Check inView value changed
	      if (cache.inView !== inView) {
	        cache.inView = inView;

	        if (inView) {
	          // Check appear
	          this.options.scenes.onAppear &&
	            this.options.scenes.onAppear.call(this, cache, parentState);
	        } else {
	          // Check disappear
	          this.options.scenes.onDisappear &&
	            this.options.scenes.onDisappear.call(this, cache, parentState);
	        }
	      }

	      if (inView) {
	        // Check is entering
	        if (this.checkEnter(cache.active, cache.progress)) {
	          cache.active = true;
	          this.options.scenes.onEnter &&
	            this.options.scenes.onEnter.call(this, cache, parentState);
	        } else if (this.checkLeave(cache.active, cache.progress)) {
	          // Check is leaving
	          cache.active = false;
	          this.options.scenes.onLeave &&
	            this.options.scenes.onLeave.call(this, cache, parentState);
	        }

	        // Run
	        if (this.options.scenes.run) {
	          this.options.scenes.run.call(this, cache, parentState);
	        }
	      }
	    });
	  }

	  getProgress(current, height, cache) {
	    let offset = current;
	    if (cache.position === 'middle') offset += height / 2;
	    if (cache.position === 'end') offset += height;
	    let progress = Math.round((offset - cache.top) * 10000 / cache.size) / 100;
	    if (progress < 0 || progress > 100) progress = -1;

	    return progress;
	  }

	  cache(parentState) {
	    return new Promise((resolve, reject) => {
	      this.state.caching = true;
	      this.state.cache = [];

	      const isVertical = this.options.direction === 'vertical';
	      const current = parentState.current;
	      const height = parentState.height;
	      const scrollOffset = parentState.target;

	      this.DOM.els.forEach((el, index) => {
	        const bounding = el.getBoundingClientRect();
	        let data = {
	          el,
	          name: el.getAttribute('data-scene'),
	          size: isVertical ? bounding.height : bounding.width,
	          top: isVertical ? bounding.top + scrollOffset : bounding.top,
	          left: isVertical ? bounding.left : bounding.left + scrollOffset,
	          bottom: isVertical ? bounding.bottom + scrollOffset : bounding.bottom,
	          position: el.getAttribute('data-scene-trigger'),
	          inView: false,
	          progress: 0
	        };

	        if (
	          data.position !== 'start' &&
	          data.position !== 'middle' &&
	          data.position !== 'end'
	        ) {
	          data.position = this.options.scenes.trigger;
	        }

	        this.state.cache.push(data);
	      });

	      this.state.caching = false;
	      resolve();
	    });
	  }

	  /*
	  ** Checkers
	  */
	  checkInView(current, height, cache) {
	    const top = Math.round(cache.top - current);
	    const bottom = Math.round(cache.bottom - current);
	    return bottom > 0 && top < height;
	  }

	  checkEnter(active, progress) {
	    return !active && progress >= 0 && progress <= 100;
	  }

	  checkLeave(active, progress) {
	    return active && progress === -1;
	  }
	}

	// Bad perfs in firefox?
	// Take a look at this ;)
	// https://bugzilla.mozilla.org/show_bug.cgi?id=1427177
	class Rolly {
	  /*
	  ** Public methods
	  */

	  constructor(options = {}) {
	    privated.bindFunc(this);

	    // Extend default options
	    this.options = privated.extOptions(options);

	    this.transformPrefix = prefix_1('transform');

	    // Instantiate virtual scroll for not native behavior
	    this.virtualScroll = this.options.native
	      ? null
	      : new src(this.options.virtualScroll);

	    this.DOM = {
	      listener: this.options.listener,
	      section: this.options.section
	    };

	    if (this.options.parallax) {
	      this.parallax = new Parallax(this.DOM.section, this.options);
	    }

	    if (this.options.scenes) {
	      this.scenes = new Scenes(this.DOM.section, this.options);
	    }
	  }

	  init() {
	    privated.initState();

	    const type = this.options.native ? 'native' : 'virtual';
	    const direction = this.options.direction === 'vertical' ? 'y' : 'x';

	    this.DOM.listener.classList.add(`is-${type}-scroll`);
	    this.DOM.listener.classList.add(`${direction}-scroll`);
	    this.DOM.section.classList.add('rolly-section');

	    this.options.preload && privated.preloadImages.call(this, privated.resize);
	    this.options.native
	      ? privated.addFakeScrollHeight()
	      : !this.options.nosrollbar && privated.addFakeScrollBar();

	    privated.addEvents();
	    privated.resize();
	  }

	  on(rAF = true) {
	    this.options.native
	      ? events.on(privated.getNodeListener(), 'scroll', privated.debounceScroll)
	      : this.virtualScroll && this.virtualScroll.on(privated.virtualScroll);

	    rAF && privated.rAF();
	  }

	  off(cAF = true) {
	    this.options.native
	      ? window.removeEventListener(
	          privated.getNodeListener(),
	          'scroll',
	          privated.debounceScroll
	        )
	      : this.virtualScroll && this.virtualScroll.off(privated.virtualScroll);

	    cAF && privated.cAF();
	  }

	  destroy() {
	    const type = this.options.native ? 'native' : 'virtual';
	    const direction = this.options.direction === 'vertical' ? 'y' : 'x';

	    this.DOM.listener.classList.remove(`is-${type}-scroll`);
	    this.DOM.listener.classList.remove(`${direction}-scroll`);
	    this.DOM.section.classList.remove('rolly-section');

	    this.options.native
	      ? privated.removeFakeScrollHeight()
	      : !this.options.nosrollbar && privated.removeFakeScrollBar();

	    this.state.current = 0;

	    this.virtualScroll &&
	      (this.virtualScroll.destroy(), this.virtualScroll = null);

	    privated.removeEvents();
	  }

	  reload(options) {
	    privated.removeEvents();
	    this.state.current = 0;
	    this.state.target = 0;

	    // Extend options
	    this.options = privated.extOptions(options);

	    this.DOM.section = options.section;
	    this.DOM.section.classList.add('rolly-section');

	    this.options.callback = options.callback;

	    this.parallax && this.parallax.reload();
	    this.scenes && this.scenes.reload();

	    this.options.preload && privated.preloadImages.call(this, privated.resize);

	    privated.addEvents();
	    setTimeout(_ => privated.resize(), 100);
	  }

	  scrollTo(target, options) {
	    options = Object.assign(
	      { offset: 0, position: 'start', callback: null },
	      options
	    );

	    const isVertical = this.options.direction === 'vertical';
	    const scrollOffset = this.state.current;
	    let bounding = null;
	    let newPos = scrollOffset + options.offset;

	    if (typeof target === 'string') {
	      target = document.querySelector(target);
	    }

	    switch (typeof target) {
	      case 'number':
	        newPos = target;
	        break;

	      case 'object':
	        if (!target) return;
	        bounding = target.getBoundingClientRect();
	        newPos += isVertical ? bounding.top : bounding.left;
	        break;
	    }

	    switch (options.position) {
	      case 'center':
	        newPos -= isVertical ? this.state.height / 2 : this.state.width / 2;
	        break;

	      case 'end':
	        newPos -= isVertical ? this.state.height : this.state.width;
	        break;
	    }

	    if (options.callback) {
	      this.state.scrollTo.callback = options.callback;
	    }

	    if (this.options.native) {
	      this.options.direction === 'vertical'
	        ? window.scrollTo(0, newPos)
	        : window.scrollTo(newPos, 0);
	    } else {
	      privated.setTarget(newPos);
	    }
	  }

	  update() {
	    privated.resize();
	  }
	}

	const privated = {
	  bindFunc(scope) {
	    for (let key of Object.keys(privated)) {
	      if (key !== 'bindFunc') {
	        privated[key] = privated[key].bind(scope);
	      }
	    }
	  },

	  initState() {
	    this.state = {
	      // Global states
	      current: 0,
	      last: 0,
	      target: 0,
	      height: window.innerHeight,
	      width: window.innerWidht,
	      bounding: 0,
	      rAF: undefined,
	      /*
	      * It seems that under heavy load, Firefox will still call the RAF
	      * callback even though the RAF has been canceled. To prevent
	      * that we set a flag to prevent any callback to be executed when
	      * RAF is removed.
	      */
	      isRAFCanceled: false,

	      // Native scroll
	      debounceScroll: { timer: null, tick: false },

	      // Scroll to
	      scrollTo: {},

	      // Virtual scroll
	      scrollbar: null
	    };
	  },

	  /*
	  ** Animation frame methods
	  */

	  // Frame request callback (called at every frames)
	  // Automatically stops when |delta| < 0.1
	  run() {
	    if (this.state.isRAFCanceled) return;
	    privated.rAF();

	    const diff = this.state.target - this.state.current;
	    let delta = diff * this.options.ease;

	    // If diff between target and current states is < 0.1,
	    // stop running animation
	    if (Math.abs(diff) < 0.1) {
	      privated.cAF();
	      delta = 0;
	      this.state.current = this.state.target;
	    } else {
	      this.state.current += delta;
	    }

	    if (Math.abs(diff) < 10 && this.state.scrollTo.callback) {
	      this.state.scrollTo.callback();
	      this.state.scrollTo.callback = null;
	    }

	    // Set section position
	    this.DOM.section.style[this.transformPrefix] = utils.getCSSTransform(
	      -this.state.current,
	      this.options.direction
	    );

	    // Set scrollbar thumb position
	    if (!this.options.native && !this.options.noscrollbar) {
	      const size = this.state.scrollbar.thumb.height;
	      const bounds =
	        this.options.direction === 'vertical'
	          ? this.state.height
	          : this.state.width;
	      const value =
	        Math.abs(this.state.current) / (this.state.bounding / (bounds - size)) +
	        size / 0.5 -
	        size;
	      const clamp = Math.max(0, Math.min(value - size, value + size));
	      this.DOM.scrollbarThumb.style[
	        this.transformPrefix
	      ] = utils.getCSSTransform(clamp.toFixed(2), this.options.direction);
	    }

	    // Call any callback
	    if (this.options.callback) {
	      this.options.callback();
	    }

	    // Parallax elements
	    this.parallax && this.parallax.run(this.state);

	    // Scenes
	    this.scenes && this.scenes.run(this.state);

	    this.state.last = this.state.current;
	  },

	  // Requests an animation frame
	  rAF() {
	    this.state.isRAFCanceled = false;
	    this.state.rAF = requestAnimationFrame(privated.run);
	  },

	  // Cancels a requested animation frame
	  cAF() {
	    this.state.isRAFCanceled = true;
	    this.state.rAF = cancelAnimationFrame(this.state.rAF);
	  },

	  calcScroll(e) {
	    const client = this.options.direction == 'vertical' ? e.clientY : e.clientX;
	    const bounds =
	      this.options.direction == 'vertical'
	        ? this.state.height
	        : this.state.width;
	    const delta = client * (this.state.bounding / bounds);

	    this.DOM.listener.classList.add('is-dragging');

	    privated.setTarget(delta);
	    this.DOM.scrollbar && (this.state.scrollbar.thumb.delta = delta);
	  },

	  /*
	  ** Events
	  */

	  addEvents() {
	    this.on();
	    window.addEventListener('resize', privated.resize);
	  },

	  removeEvents() {
	    this.off();
	    window.removeEventListener('resize', privated.resize);
	  },

	  // Virtual scroll event callback
	  virtualScroll(e) {
	    if (this.state.scrollTo.callback) return;
	    const delta = this.options.direction === 'horizontal' ? e.deltaX : e.deltaY;
	    privated.setTarget(this.state.target + delta * -1);
	  },

	  // Native scroll event callback
	  debounceScroll() {
	    if (this.state.scrollTo.callback) return;
	    const isWindow = this.DOM.listener === document.body;

	    let target =
	      this.options.direction === 'vertical'
	        ? isWindow
	          ? window.scrollY || window.pageYOffset
	          : this.DOM.listener.scrollTop
	        : isWindow
	          ? window.scrollX || window.pageXOffset
	          : this.DOM.listener.scrollLeft;

	    privated.setTarget(target);

	    clearTimeout(this.state.debounceScroll.timer);

	    if (!this.state.debounceScroll.tick) {
	      this.state.debounceScroll.tick = true;
	      this.DOM.listener.classList.add('is-scrolling');
	    }

	    this.state.debounceScroll.timer = setTimeout(_ => {
	      this.state.debounceScroll.tick = false;
	      this.DOM.listener.classList.remove('is-scrolling');
	    }, 200);
	  },

	  // Resize event callback
	  resize(e) {
	    const prop = this.options.direction === 'vertical' ? 'height' : 'width';
	    this.state.height = window.innerHeight;
	    this.state.width = window.innerWidth;

	    // Calc bounding
	    const bounding = this.DOM.section.getBoundingClientRect();
	    this.state.bounding =
	      this.options.direction === 'vertical'
	        ? bounding.height - (this.options.native ? 0 : this.state.height)
	        : bounding.right - (this.options.native ? 0 : this.state.width);

	    // Set scrollbar thumb height (according to section height)
	    if (!this.options.native && !this.options.nosrollbar) {
	      this.state.scrollbar.thumb.height =
	        this.state.height *
	        (this.state.height / (this.state.bounding + this.state.height));
	      this.DOM.scrollbarThumb.style[prop] = `${
        this.state.scrollbar.thumb.height
      }px`;
	    } else if (this.options.native) {
	      this.DOM.scroll.style[prop] = `${this.state.bounding}px`;
	    }

	    !this.options.native && privated.setTarget(this.state.target);

	    // Get cache for parallax elements
	    this.parallax && this.parallax.cache(this.state);

	    // Get cache for scenes
	    this.scenes && this.scenes.cache(this.state);
	  },

	  // Scrollbar thumb click & mouse move events callback

	  // Scrollbar click event callback
	  mouseDown(e) {
	    e.preventDefault();
	    e.which === 1 && (this.state.scrollbar.clicked = true);
	  },

	  // Mouse move event callback
	  mouseMove(e) {
	    this.state.scrollbar.clicked && privated.calcScroll.call(this, e);
	  },

	  // Mouse up event callback
	  mouseUp(e) {
	    this.state.scrollbar.clicked = false;
	    this.DOM.listener.classList.remove('is-dragging');
	  },

	  /*
	  ** Utils
	  */

	  // Extend options
	  extOptions(options) {
	    console.log(this);
	    const opts = this.options ? this.options : privated.getOptions();
	    options.virtualScroll = Object.assign(
	      opts.virtualScroll,
	      options.virtualScroll
	    );
	    options.parallax = Object.assign(opts.parallax, options.parallax);
	    options.scenes = Object.assign(opts.scenes, options.scenes);

	    return Object.assign(opts, options);
	  },

	  // Preload images of section to make sure `this.state.height`
	  // contains real images height
	  preloadImages(callback) {
	    const images = Array.prototype.slice.call(
	      this.DOM.listener.querySelectorAll('img'),
	      0
	    );

	    images.forEach(image => {
	      const img = document.createElement('img');
	      img.onload = _ => {
	        images.splice(images.indexOf(image), 1);
	        images.length === 0 && callback && callback();
	      };

	      img.src = image.getAttribute('src');
	    });
	  },

	  // Add a fake scroll height
	  addFakeScrollHeight() {
	    const scroll = document.createElement('div');
	    scroll.className = 'rolly-scroll-view';
	    this.DOM.scroll = scroll;
	    this.DOM.listener.appendChild(this.DOM.scroll);
	  },

	  // Remove the fake scroll height
	  removeFakeScrollHeight() {
	    this.DOM.listener.removeChild(this.DOM.scroll);
	  },

	  // Add a fake scroll bar
	  addFakeScrollBar() {
	    const scrollbar = document.createElement('div');
	    scrollbar.className = `rolly-scrollbar rolly-${this.options.direction}`;
	    this.DOM.scrollbar = scrollbar;

	    const scrollbarThumb = document.createElement('div');
	    scrollbarThumb.className = 'rolly-scrollbar-thumb';
	    this.DOM.scrollbarThumb = scrollbarThumb;

	    this.state.scrollbar = {
	      clicked: false,
	      x: 0,
	      thumb: { delta: 0, height: 50 }
	    };

	    this.DOM.listener.appendChild(this.DOM.scrollbar);
	    this.DOM.scrollbar.appendChild(this.DOM.scrollbarThumb);

	    this.DOM.scrollbar.addEventListener('click', privated.calcScroll);
	    this.DOM.scrollbar.addEventListener('mousedown', privated.mouseDown);

	    document.addEventListener('mousemove', privated.mouseMove);
	    document.addEventListener('mouseup', privated.mouseUp);
	  },

	  // Remove the fake scroll bar
	  removeFakeScrollBar() {
	    this.DOM.scrollbar.removeEventListener('click', privated.calcScroll);
	    this.DOM.scrollbar.removeEventListener('mousedown', privated.mouseDown);

	    document.removeEventListener('mousemove', privated.mouseMove);
	    document.removeEventListener('mouseup', privated.mouseUp);

	    this.DOM.listener.removeChild(this.DOM.scrollbar);
	  },

	  /*
	  ** Getters and setters
	  */

	  getOptions() {
	    return {
	      direction: 'vertical',
	      native: false,
	      ease: 0.075,
	      preload: false,
	      virtualScroll: {
	        limitInertia: false,
	        mouseMultiplier: 0.5,
	        touchMultiplier: 1.5,
	        firefoxMultiplier: 30,
	        preventTouch: true
	      },
	      listener: document.body,
	      section: document.querySelector('.rolly-section') || null,
	      parallax: {
	        selector: '[data-parallax]'
	      },
	      scenes: {
	        selector: '[data-scene]',
	        trigger: 'middle'
	      },
	      callback: null
	    };
	  },

	  getNodeListener() {
	    return this.DOM.listener === document.body ? window : this.DOM.listener;
	  },

	  setTarget(target) {
	    this.state.target = Math.round(
	      Math.max(0, Math.min(target, this.state.bounding))
	    );
	    !this.state.rAF && privated.rAF();
	  }
	};

	return Rolly;

})));
